#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<string.h>
//int main()
//{
//	char a[] = "abcdef";
//	printf("%d \n", strlen(a));//6
//	printf("%d \n", strlen((char *) & a));//6
////strlen(a)，a是首元素的地址
////strlen(&a)，&a是整个数组的地址，但整个数组的地址还是从首元素的地址开始的。所以也可以算出字符串的长度。需将&a强制转换为char*。&a是数组指针。
//	return 0;
//}
//int main()
//{
//	const char* p = "abcdef";
//	//p存放的是首元素的地址。
//	printf("%d \n", sizeof(p[0]));//p[0]=='a';
//	//int arr[10],*arr==arr[0]
//	printf("%d \n", sizeof(*p));//*p=='a';
//	return 0;
//}
//void test(char x[])//此处char x[]本质是char* x
//{
//	printf("%p ", x); //000000714072FB84
//	printf("%p ", &x); //000000714072FB60
//	printf("%p \n", &x[0]);// 000000714072FB84
//}
//int main()
//{
//	char arr[7] = "abcdef";//创建一个字符数组，数组arr的地址就是首元素的地址
//	printf("%p \n", arr); //000000714072FB84，arr是首元素的地址
//	printf("%p \n", &arr); //000000714072FB84，&arr是整个数组的地址，从首元素的地址开始
//	printf("%p \n", &arr[0]);// 000000714072FB84//&arr[0]是首元素的地址
//	const char* p= "abcdef";//创建一个指针变量存放"abcdef"，p存放的是首元素的地址。p有自己的地址
//	printf("%p \n", p); //00007FF6A64F9C10，首元素的地址
//	printf("%p \n", &p); //000000714072FBA8，&p是p的地址，不是字符串的地址
//	printf("%p \n", &p[0]);// 00007FF6A64F9C10，&p[0]是首元素的地址
//	//p和arr，除了arr的地址就是首元素的地址，p有自己的地址外，其余的都相同
//	test(arr);
//	return 0;
//}
//int main()
//{
//	int a[3][4] = { 0 };
//	//a是二维数组，三行四列，如果将a看成一维数组的话，每一行就是（一个一维数组）一个元素。有三个元素。
//	//a[0],就是第一行一维数组的数组名，a[1],就是第二行一维数组的数组名,a[2]就是第三行一维数组的数组名
//	//a的首元素地址就是第一行一维数组（整个数组）的地址。
//	printf("%d\n", sizeof(a));//3*4*4;a代表是整个数组
//	printf("%d\n", sizeof(a[0][0]));//4
//	printf("%d\n", sizeof(a[0]));//16；a[0]是第一行一位数组的数组名，计算的是第一行一维数组的大小
//	printf("%d\n", sizeof(a[0] + 1));//4/8，a[0]是第一行首元素的地址，a[0]+1,是第一行第二个元素的地址。
//	printf("%d\n", sizeof(*(a[0]+1)));//4；a[0]+1,是第一行第二个元素的地址，*(a[0]+1))是第一行第二个元素
//	printf("%d\n", sizeof(a+1));//4/8；a是首元素的地址就是第一行一维数组（整个数组）的地址。a+1，就是第二行一维数组的地址
//	printf("%d\n", sizeof(&a[0]+1));//4/8；&a[0]是第一行一维数组的地址，&a[0]+1就是跳过第一行一维数组的地址（第二行一维数组的地址）
//	printf("%d\n", sizeof(*(&a[0] + 1)));//16；*(&a[0] + 1)就是第二行一维数组
//	printf("%d\n", sizeof(*a));//16；*a是第一行一位数组
//	printf("%d\n", sizeof(a[3]));//16；sizeof()括号中的表达式并未进行运算，所以没有违规，只通过数组的类型计算所占空间的大小。求的是第四行一维数组的大小。
//	return 0;
//}
//int main()
//{
//	int arr[10] = { 0 };
//	printf("%p\n", &arr);
//	printf("%p\n", &arr[10]);
//	printf("%p\n", &arr[20]);
//	printf("%p\n", &arr + 2);
//	printf("%p\n", &arr + 1);
//	//&arr是整个数组的地址。&arr[0]->&arr[9]
//	//&arr+1，是跳过整个数组的地址，下一个数组的地址；即arr[10]->arr[19]
//  //指针中存放的内容大小不改变，即p中存放的是int[10],整个数组的地址
//  //p1=p+1，p1存放的是跳过int[10]这个数组，下一个int[10]整个数组的地址。
//  //p+一个整数，存放的仍是一个（int [10]）数组的地址
//	return 0;
//}
//struct test 
//{
//	int num;
//
//}* p;//创建一个结构体指针变量p；结构体test的类型的变量占20个字节。
////p每次访问的内存大小是20字节。p的步长是20字节
//
//int main()
//{
//	p = (struct test*)0x100000;
//	printf("%p\n", p + 0x1);//0000000000100004//p+1，就是0x100000加16
//	printf("%d\n", (unsigned long)p + 0x1);//0000000000100001；p被强制转换为无符号长整型即正常加减计算，就是0x100000+1
//	printf("%p\n", (int *)p + 0x1);//0000000000100004//p被强制转换为int*，//p+1就是0x1000000+1
//	return 0;
//}
//int main()
//{
//	int a[4] = { 1,2,3,4 };
//	int* ptr = (int*)(&a + 1);//ptr是a[4]的地址
//	int* ptr2 = (int*)((int)a + 1);
//	printf("%x,%x\n", ptr[-1], *ptr2);
////ptr[-1],相当于*(ptr-1)就是a[3]
////a是首元素的地址，强制转换为int，假如a的地址是0x00000005，a+1==0x00000006.再强制转换为int*，也就是地址升高了一个字节，
////a数组在内存中的存储为01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00；地址是占四个字节的。
////也就是a的地址是从01开始的，现在prt2升高了一个字节，从00开始向后读取四个字节就是00 00 00 02，数字就是0x02000000；       
//	return 0;
//}
//int main()
//{
//	int a[5][5];
//	int(*p)[4];
//	p = (int(*)[4])a;
//	printf("%p,%d", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
//	//p是一个数组指针指向一个有四个元素的地址，类型是int
//	//p中存的是a第一行前四个元素的地址。p[4]相当于*(p+4),p[4][2]相当于*(p+4)这个数组中的第三个元素。就是a[3][3]
//	//指针相减是，两个指针间的元素个数。7-3==4;下标相减。
//	//%p打印的是-4的补码。%p相当于打印的是无符号数字
//	//-4 10000000000000000000000000000100
//	//   11111111111111111111111111111011
//	//   1111 1111 1111 1111 1111 1111 1111 1100
//	//    F    F     F   F    F    F    F     C
//	//0xFFFFFFFC,-4
//	return 0;
//}
//int main()
//{
//	int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* ptr1 = (int*)(&aa + 1);//&aa是整个二维数组的地址，&aa+1，是跳过整个数组，即从aa[2][0]开始向后的10个元素组成的二维数组，地址从a[2][0]开始。强制转换为int*后，ptr1就是aa[2][0]的地址。
//	int* ptr2 = *(aa + 1);//aa是数组名，数组名是首元素的地址就是第一行一维数组的地址。aa+1就是第二行一维数组的地址，*(aa+1)就是第二行一维数组相当于aa[1]即第二行一维数组的数组名（第二行一维数组首元素的地址即&aa[1][0]）;ptr2就是&aa[1][0]
//	printf("%d,%d", *(ptr1 - 1), *(ptr2 - 1));//ptr1-1就是&aa[1][4];ptr2-1就是&aa[0][4]
//	return 0;
//}
//int main()
//{
//	const char* a[] = {"work","at","alibaba"};
//	const char** p = a;//a[0]中存入的是work中w的地址，a[1]中存入的是at中a的地址，a[2]中存入的是alibaba中a的地址，
//	p++;//p存入的是w的地址，p++存入的是at中a的地址
//	printf("%s", *p);//打印at。
//	return 0;
//}
//int main()
//{
//	const char* a = "abc";
//	const char* b = "abcd";
//	printf("%p\n%p", a, b);// 00007FF728BC9CA4 00007FF728BC9C80
//	printf("\n%p", a + 1);// 00007FF728BC9CA5
//	return 0;
//}
//int main()
//{
//	const char* c[] = { "ENTER","NEW","POINT","FIRST" };
//	//c[0]中存入的是E的地址（&'E'）；c[1]中存入的是N的地址（&'N'）；c[2]中存入的是P的地址（&'P'）；c[3]中存入的是F的地址（&'F'）
//	//c是首元素地址&c[0]==&&'E'
//	//&c[0]+1=&c[1],&c[0]+2=&c[2],&c[0]+3=&c[3]
//	const char** cp[] = { c + 3,c + 2,c + 1,c };
//	//c是首元素的地址即&c[0]==&&E
//	//cp[0]==c+3==&c[0]+3==&c[3]
//	//cp[1]==c+2==&c[0]+2==&c[2]
//	//cp[2]==c+1==&c[0]+1==&c[1]
//	//cp[3]==c==&c[0]
//	const char*** cpp = cp;
//	//cpp==&cp[0];
//	printf("%s\n", **++cpp);
//	//cpp=cpp+1==&cp[0]+1==&cp[1];**(cpp)==*(cp[1])==*(&c[2])==c[2]==打印Point
//	//此时cpp===&cp[1]
//	printf("%s\n", *--*++cpp+3);
//	//cpp=cpp+1==&cp[1]+1==&cp[2],*(&cp[2])==c+1,c+1=c+1-1==c,*c==&'E',*c+3=='E',打印ER
//	//此时cpp==&cp[2]
//	printf("%s\n", *cpp[-2]+3);
//	//cpp[-2]==*(cpp-2)==*(&cp[0])==cp[0],*(cp[0])==&'F',&'F'+3==&'S';打印ST；
//	//此时cpp==&cp[2]
//	printf("%s\n", cpp[-1][-1]+1);
//	//cpp[-1][-1]==*(cpp[-1]-1)==*(*(cpp-1)-1)==&'N',&'N'+1=='E',打印EW。
//	return 0;
//}



