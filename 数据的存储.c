#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//c语言类型
// 1.自定义类型（构造类型）:
// 数组类型
// 结构体类型struct
// 枚举类型enum
// 联合类型union
// 2.内置类型：
//char 字符数据 1字节
//short 短整型 2字节
//long  长整型 4字节
//long long 更长的整型 8字节
//int 整型 4字节
//float 单精度浮点数 4字节
//double 双精度浮点数 8字节
// 3.指针类型：
// int*
// char*
// 4.空类型：
// void表示空类型（无类型）
// 通常用于函数的参数，函数的返回类型，指针类型
//类型的意义：
//1.使用这个类型开辟内存空间的大小；
//2.如何看待内存空间的视角
//
//整型家族 :
// char:
// unsigned char
// signed char
// short:
// unsigned short[int]
// signed short[int]
// int:
// unsigned int
// signed int
// long:
// unsigned long[int]
// signed long[int]
// 
// 计算机中整型有符号数有三种表示方法：原码，反码，补码。
// 三种表示方法均有符号位和数值位两部分。符号位都是用0表示正，用1表示负。而数值位表示方法不同。
// 整型无符号数，也有三种表示方法：原码，反码，补码。只不过三种表示方法数据相同，即三码合一。正数也是三码合一
// 原码：直接将数字按照正负的形式翻译为二进制即可。4：00000000000000000000000000000100；-1：10000000000000000000000000000001;
// 反码：将原码符号位不变，其他位按位取反          4：00000000000000000000000000000100；-1：11111111111111111111111111111110；
// 补码：反码+1；                                  4：00000000000000000000000000000100；-1：11111111111111111111111111111111；
//对于整型来说 ,计算机内存的是二进制序列的补码
//
// 大端（存储）模式：数据的低位保存在内存的高地址，而数据的高位保存在内存的低地址。
// 0x11223344  数据从右向左升高       内存的地址从左向右升高   内存中存储为  11 22 33 44
// 小端（存储）模式：数据的高位保存在内存的高地址，而数据的低位保存在内存的低地址。
// 0x11223344  数据从右向左升高       内存的地址从左向右升高   内存中存储为  44 33 22 11
// 
// 
// 
// 
//
//int check_sys(void)
//{
//	int a = 1;
//	return *(char*)&a;
//	/*char* p = (char*)&a;
//	return *p;*/
//	/*if (*p == 1)
//		return 1;
//	else
//		return 0;*/
//}
//
//int main()
//{
//	if (check_sys() == 1)
//		printf("小端");
//	else
//		printf("大端");
//	return 0;
//}
//int main()
//{
//	int a = 0x11223344;//内存中的存储方式为44 33 22 11
//	int i = 0;
//	char* p = (char*)&a;
//	for (i = 0; i < 4; i++)
//	{
//		if (*p != a%256)//*p的值会随着a的改变而改变。*p是a内存中的第一个字节。改变a，*p也会改变，a和*p是一个值。
//			break;
//		a = a / 256;
//	}                     //i=0;*p==44,a=0x11223344,a%256==44
//	                      //然后a=a/256，a==0x112233；内存中为33 22 11 00；所以此时*p==33；
//	                      //i=1;*p==33，a%256==33，循环下去直至循环结束。
//	                      //
//	if (i == 4)
//		printf("小端");
//	else
//		printf("大端");
//	return 0;
//}
//int main()//先把正数变为二进制原码，再求出补码，再进行截断存入，再整型提升补码（内存中存的是补码），求出补码整型提升后的原码进行打印。
//{
//	            //补码11111111111111111111111111111111;                             有符号补符号位，无符号补0
//	char a = -1;//原码10000000000000000000000000000001,存入char类型，截断a=11111111,整型提升  11111111111111111111111111111111；算出原码10000000000000000000000000000001 。打印-1.
//	signed char b = -1;//char a默认就是有符号的，于a相同。
//	unsigned char c = -1;//11111111111111111111111111111111,存入unsigned char,截断c=11111111，无符号为正，整型提升00000000000000000000000011111111；正数三码合一 打印255；
//	printf("a=%d,b=%d,c=%d", a, b, c);
//	return 0;
//}
//int main()
//{
//	char a = -128;
//	//-128原码为10000000000000000000000010000000
//	//    反码为11111111111111111111111101111111
//	//    补码为11111111111111111111111110000000
//	//存入到a中发生截断，a中存入的是10000000
//	// 打印是a发生整型提升有符号补符号位
//	// 提升后的补码为11111111111111111111111110000000
//	// 由于要求打印的是无符号十进制数字
//	// 即11111111111111111111111110000000为十进制无符号数字，三码合一，
//	// 原码为11111111111111111111111110000000
//	//打印原码11111111111111111111111110000000即4294967168
//	printf("%u", a);//%u打印无符号10进制数字
//	return 0;
//}
//有符号的char的范围是-128--->127
// 10000000定义为-128，
// 可以把10000000认为是前面还有个1，即110000000，就是补码，求出其原码110000000，为-128
// 在内存中127==01111111//正数三码合一
//        -127==10000001//内存中存的是补码求出原码为11111111；-127
// 无符号char范围是0-->255.
//
//int main()
//{
//	char a = 128;//128不能存入，128=127+1；127 原码，补码为01111111；加1（都是正数三码合一为10000000，
//	//10000000定义为-128.输出于上一个程序相同。
//	printf("%u", a);//4294967168
//
//	return 0;
//}

//int main()
//{
//	int a = -20;
//	//原码 10000000000000000000000000010100
//	//反码 11111111111111111111111111101011
//	//补码 11111111111111111111111111101100
//	unsigned int b= 10;
//	//b为正数，三码合一
//	//00000000000000000000000000001010
//	printf("%d", a + b);
//	//a+b时发生算式转换，把a转换为无符号整数，再相加
//	//11111111111111111111111111101100+
//	//00000000000000000000000000001010
//	//11111111111111111111111111110110,相加是补码
//	//打印的是有符号整数，再转换为有符号整数11111111111111111111111111110110
//	//求出原码，10000000000000000000000000001010
//	//再打印
//	return 0;
//}
//9 //00000000000000000000000000001001
//-1//10000000000000000000000000000001
//    11111111111111111111111111111110
//    11111111111111111111111111111111+
//    00000000000000000000000000001001 
//  1 00000000000000000000000000001000 补码1超出，舍掉
//    00000000000000000000000000001000 8
//0 //00000000000000000000000000000000+
//    11111111111111111111111111111111
//    11111111111111111111111111111111 补码
//    11111111111111111111111111111110
//    10000000000000000000000000000001 
//int main()
//{
//	unsigned int i;//i规定是无符号数，i一定大于等于0；
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u", i);
//	}
//	//i-- == i=i-1,无符号数-一个有符号整数，需要算式转换。
//	//i==9时//00000000000000000000000000001001
//	   //-1//10000000000000000000000000000001原码
//           //11111111111111111111111111111110反码
//           //11111111111111111111111111111111补码
////00000000000000000000000000001001+11111111111111111111111111111111
////1 00000000000000000000000000001000算出的是补码，1超出int的大小 舍弃；i==00000000000000000000000000001000==8
////按此循环下去，直至i==0
////0 //00000000000000000000000000000000
////-1//10000000000000000000000000000001 原码
////  //11111111111111111111111111111110 反码 
////  //11111111111111111111111111111111 补码
////  //00000000000000000000000000000000+11111111111111111111111111111111
////  //11111111111111111111111111111111算出的补码，也是i的二进制。i是无符号整数，所以11111111111111111111111111111111没有符号位
////  //i==4294967295
////i>=0,循环继续，当i再次为0是，又会出现上面的情况，就会产生死循环。
//	return 0;
//}
// 11111111111111111111111111111111
// 00000000000000000000000000000000
// 11111111111111111111111111111111
// 10000000000000000000000000000001
// 11111111111111111111111111111111
// 11111111111111111111111111111111
//111111111111111111111111111111110
// 11111111111111111111111111111110
// 10000000000000000000000000000010 -2
// 11111111111111111111111111111111
// 10000000000000000000000000000000
//110000000000000000000000000000000
//101111111111111111111111111111111
//110000000000000000000000000000000
//#include<string.h>
//int main()
//{
//	char a[1000];
//	int i = 0;
//	for (i = 0; i < 1000; i++)
//		a[i] = -1 - i;
//	//i=0;时-1//补码11111111111111111111111111111111
//	//       0//补码00000000000000000000000000000000
//	// 相加     补码11111111111111111111111111111111    
//	// 截断     补码11111111，原码10000001==-1                       
//	//i=1;时-1//补码 11111111111111111111111111111111
//	//      -1//补码 11111111111111111111111111111111
//	// 相加     补码111111111111111111111111111111110，左边多出一位舍弃，11111111111111111111111111111110
//	// 截断    补码11111110，原码10000010==-2
//	// .......
////i=127；时 -1//补码 11111111111111111111111111111111
//	//    -127//补码 11111111111111111111111110000001
//	// 相加     补码111111111111111111111111110000000，左边多出一位舍弃，11111111111111111111111110000000      
//	// 截断     补码10000000，原码是==-128
////i=128；时 -1//补码 11111111111111111111111111111111 
//	//    -128//补码 11111111111111111111111110000000
//	// 相加     补码100000000000000000000000001111111，左边多出一位舍弃，00000000000000000000000001111111
//	// 截断     补码01111111，为正数，三码合一 原码01111111==127
////i=129；时 -1//补码 11111111111111111111111111111111 
//	//    -129//补码 11111111111111111111111101111111
//	// 相加     补码111111111111111111111111101111110，左边多出一位舍弃，11111111111111111111111101111110
//	// 截断     补码01111110，为正数，三码合一 原码01111111==126
//	// ........
////i=255；时 -1//补码 11111111111111111111111111111111 
//	//    -255//补码 11111111111111111111111100000001
//	// 相加     补码111111111111111111111111100000000，左边多出一位舍弃，11111111111111111111111100000000
//	// 截断     补码00000000，为正数，三码合一 原码00000000==0	
////i=256；时 -1//补码 11111111111111111111111111111111 
//	//    -256//补码 11111111111111111111111100000000
//	// 相加     补码111111111111111111111111011111111，左边多出一位舍弃，11111111111111111111111011111111
//	// 截断     补码11111111， 原码10000001==-1
//	// ......直至循环结束
//	//从-1开始赋值->-128,下一次赋值直接变为127，再从127->0,再从0->128,下一次赋值直接变为127,再从127->0，一直循环直至循环结束
//	// 
//	// 
//	// 
//	//
//	printf("%d", strlen(a));//strlen在遇到'\0'时停止，'\0'的ASCII为0；即求-1->-128和127->1,一共有多少个数，有128+127==255 个数。
//	return 0;
//}
//i=i+1
//00000000000000000000000000000000//0
//00000000000000000000000000000001//1相加
//00000000000000000000000000000001
//00000001==1
//00000000000000000000000011111111//255
//00000000000000000000000000000001//1
//00000000000000000000000100000000//相加
//00000000==0
//int main()
//{
//	unsigned char i = 0;//unsigned char的范围是0->255，条件恒成立，255+1==0；
//	for (i = 0; i <= 255; i++)
//		printf("hello world\n");//死循环
//
//	return 0;
//}
//根据标准规定，任何一个二进制浮点数V都可以成下面的形式。
//(-1)^S*M*2^E;
// S是符号位S=0,时为正数，S=1，时为负数。
// M是有效数字   1<=M<2.
// 2^E是指数位
//9.0的二进制序列为1001.0可以写为(-1)^0*1.001*2^3;
//对于32位的（单精度）浮点数，最高的一位（1bit）是符号位S，接下来的8位（8bit）是指数E，剩下的23位（23bit）是有效数字M。
//对于64位的（双精度）浮点数，最高的一位（1bit）是符号位S，接下来的11位（11bit）是指数E，剩下的52位（52bit）是有效数字M。
//因为1<=M<2,即M=1.XXXX；其中XXXX为小数部分，标准规定在保存M是默认这个数的第一位是1，因此可以被省略，故只保存小数部分
//即1.202；1被舍弃只保存202；到读取是再添上第一位1。目的，可以节省1位有效数字，提高精度
//对于指数E情况比较复杂
//首先E是一个无符号数，对于32位浮点数E的范围是0-->255;对于64位浮点数E的范围是0-->2047。
//但是指数可以是负数，故E也要可以表示负数。
//标准规定对于32位浮点数，去E取值范围的中间值127.存入内存中的E都要加上中间值127;0->127表示负数，128->255表示正数。
//        对于64位浮点数，去E取值范围的中间值1023.存入内存中的E都要加上中间值1023;0->1023表示负数,1024->2047表示正数。
//例//0.5//二进制序列为0.1；(-1)^0*1*2^(-1);E==-1，那么对于32位浮点数存入内存中的E就是-1+127==126;对于64位浮点数存入内存中的E就是-1+1023==1022
//  //8.5//二进制序列为1000.1；(-1)^0*1.0001*2^3;E==3,那么对于32位浮点数存入内存中的E就是3+127==130;对于64位浮点数存入内存中的E就是3+1023==1026 
// 8.5//存入内存中是0 10000010 0001(后面补0)0000000000000000000//0001本来就是二进制所以直接存入再补0补满23位
//                //01000001000010000000000000000000
// 指数E从内存中取出还可以分为三种情况
// 1.E不全为0且不全为1：E的内存中存的二进制位转换为十进制位，再减去127（32位浮点数）或1023（64位浮点数），得到真实值，再将有效数字M前加上第一位的1和小数点（.），计算出结果
// 例8.5// 0 10000010 00010000000000000000000（32位）
// 10000010==130 ，130-127==3，得到真实值E==3,
// 有效数字M前加上第一位的1和小数点（.），即 M==1.00010000000000000000000
// 计算(-1)^0*1.0001*2^3==8.5,得出结果。
// 例0.5// 0 01111110 00000000000000000000000（32位）
// 01111110==126，126-127==-1，得到真实值E==-1,
// 有效数字M前加上第一位的1和小数点（.），即 M==1.00000000000000000000000
// 计算(-1)^0*1.0000*2^(-1)==0.5,得出结果。
// 2.E全为0
// 这时，规定浮点数的E（真实值）等于1-127（32位浮点数）或1-1023（64位浮点数）；有效位M前不再加上第一位的1和小数点（.）
// 而是有效位M前加上第一位的0和小数点（.），还原为0.XXXX的小数，为了更好的表示正负0，和无限接近0的小数
//例 1 00000000 1100000000000000000000（32位）
// E==1-127==-126
// M==0.1100000000000000000000
// 计算(-1)^1*0.1100*2^(-126)
//
// 3.E全为1
//  11111111==255
// E的真实值位255-127==128
// 根据符号位可以表示正负无穷大
//  
//int main()
//{
//	int a = 9;
//	//存入到内存是0000000000000000000000000001001补码 （三码合一）
//	float* p = (float*)&a;
//	printf("a==%d\n", a);//打印9
//	printf("*p==%lf\n", *p);
//	//由于p的类型是float*，所以*p的类型也是float，即把a当成float类型打印
//	//0 00000000 0000000000000000001001
//	//E==1-127==-126
//	//M=0.0000000000000000001001
//	//计算(-1)^0*0.0000000000000000001001*2^(-126)无限接近于0；打印0；
//	*p = 9.0;
//	//将a中按浮点数存入9.0
//	// 9.0的二进制序列是1001.0;
//	// (-1)^0*1.001*2^3
//	// E==3;
//	// M==1.001
//	// E的存储值是3+127==130；
//	// 0 10000010 00100000000000000000000
//	//存入到内存中的数据。
//	printf("a==%d\n", a);
//	//a的类型是int，按照int的类型打印
//	//01000001000100000000000000000000
//	//打印1091567616
//	printf("*p==%lf\n", *p);//打印9.0
//	return 0;
//}
